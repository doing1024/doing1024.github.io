# ST表介绍

## 什么是RMQ问题

RMQ（区间最值问题），指对于一个序列$A$，询问每一对$(i,j)$，求$a_i ~ a_j$之间的最大（或小）值。一般这样的问题，一般会有很多次询问。

## 什么是ST表

ST 表（Sparse Table，稀疏表）是用于解决 **可重复贡献问题** 的数据结构。

## 什么是可重复贡献问题

可重复贡献问题是指，对于一个运算$opt$，满足$x opt x = x$，则对应$opt$操作的区间查询问题就是**可重复贡献问题**。
比如，$max(x,x) = x$，$min(x,x) = x$，所以RMQ（区间最值问题）属于可重复贡献问题，可以用**ST表**解决。注意，对于其他可重复贡献问题，$opt$必须满足交换率才能用**ST表**解决。

# 例题

[P3865 【模板】ST 表 && RMQ 问题](https://www.luogu.com.cn/problem/P3865)

题目大意：给定两个数$N$和$M$，下面一行$N$个数，表示$a_1 ~ a_n$，接下来$M$行,每行两个数$l$和$r$，输出$max(a_l,a_{l+1},a_{l+2},...,a_r)$。

# 做法

我们首先用$\mathcal{O}(n \log(n))$的时间复杂度处理出序列中每个长度为$2^x$次方的区间。我们就可以发现，任意一个区间都可以用至多两个预处理过的区间覆盖。所以可以用$\mathcal{O}(1)$的时间复杂度求解每一个询问。

因为$max$满足可重复贡献，所以两个预处理过的区间重合的部分不会影响结果。这也是为什么ST表不能求区间和的原因。

## 具体实现

我们设定一个数组f用来储存”每个长度为$2^x$次方的区间“,设$f_{i,j}$为区间$[i,i + 2^j - 1]$的最大值。
每个长度为1的区间的最大值都是这个数自己。即所有$f_{i,0} = a_i$。

对于其它的区间，我们不必遍历整个区间去寻找最大值。我们可以将其分为两个区间，取两个区间的最大值的最大值（请仔细理解这句话）即可。所以$f_{i,j} = max(f_{i,j - 1},f_{i + 2^{j - 1},j - 1})$
预处理部分参考代码：

```cpp
// 初始st[i][0] = a[i]，此处省略
// log2[n] 为log2(n)，通过for循环预处理实现
for (int step = 1; step <= log2[n]; ++step) // 因为log2(n) ^ n = n，因此循环到log2[n]
    for (int i = 1; i + (1 << step) - 1 <= n; ++i) // 循环到末尾，防止越界
        f[step][i] =
            max(f[step - 1][i], f[step - 1][i + (1 << (step - 1))]); // 取两个子区间的最大值
```

到现在，预处理部分已经完成了，下面我们来看看如何实现$\mathcal{O}(1)$的查询。
跟据可重复贡献问题的性质，我们无需取两个正好拼接的序列，只需要取得两个序列覆盖询问序列即可。所以对于区间$(l,r)$，两个区间分别是$[l,l + 2^s - 1]$和$[r - 2^s + 1,r]$，其中$s = \lfloor \log_2(r - l + 1) \rfloor$。两个部分的最大值就是答案，下面给出询问部分的代码。

```cpp
// l,r是输入给定的数
t = log2[r - l + 1];
max(f[t][l],f[t][r - (1 << t) + 1]); // 求两个区间的最大值，注意下标第二维是指区间长度为2^x次方，不是右端点
```
