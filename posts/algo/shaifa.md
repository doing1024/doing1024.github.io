# 概念

1. 素数：除了0、1，没有1和自身以外的因子的自然数，又称质数
2. 合数：除了质数和0、1以外的所有自然数
3. 筛法：一般指通过一些方法筛选 $1$ ～ $n$之间所有质数的方法

# 方法1：逐个判断

相信大家一定都会判断单个数是不是质数，这时我们对每一个数进行一次 $\mathcal{O}(\sqrt{x})$ 的判断，就可以得出所有的质数，时间复杂度为 $\mathcal{O}(n \sqrt{x})$ 。仍然不懂可以参考代码:

```cpp
#include<iostream>
using namespace std;
int prime(int n){
    for(int i = 2;i * i <= n;++i){ // 只需要到根号n就可以了
    	if(n % i == 0) return 0;
    }
    return 1;
}
int n;bool ans[100]; // ans是结果，质数为1，合数为0
int main(){
    cin >> n;
    for(int i = 1;i <= n;++i) ans[i] = prime(i);
    return 0;
}
```

# 方法2：埃筛

我们可以定义一个数组`ans`，如果 $ans_i = 1$ ，则代表 $i$ 是素数，反之则是合数。

首先假设我们“信任”每一个数，即假设每一个数都是质数，也就是把每一个数的`ans`都标记为1。

然后从2开始看每一个数，如果这个数目前为止仍然“被信任”，即`ans`是1，则它是质数，反之则是合数。

如果它是质数，则接着看它的所有倍数，既然都是它的倍数，那么肯定不是质数，这时我们“恍然大悟”，不再“信任”这些数，把他们的`ans`标记为0。

看完所有数后，`ans`为1的数都是质数。
代码：

```cpp
bool prime[100];
void judge_prime(int n){
    memset(prime,1,sizeof(prime)); // 一开始“信任”所有数
    for(int i = 2;i <= n;++i) // 开始看每一个数，注意从2开始
        if(prime[i] == 1) // 如果目前为止仍然“被信任”，则是素数
            for(int j = i * 2;j <= n;j += i) // 不再“信任”素数的倍数
                prime[j]=0;
}
```

以上代码我们还可以继续优化，首先，`j`可以从`i * i`开始，因为`2 * i`、...、`i - 1 * i`已经被2到`i - 1`标记过了，所以从`i * i`开始即可。其次，`i`到根号n就可以了，因为所有数的每一对因子一定有一个大于根号n，另一个小于根号n，，所以到根号n的时候所有合数就都会被标记过了。
优化后代码：

```cpp
bool prime[100];
void judge_prime(int n){
    memset(prime,1,sizeof(prime)); // 一开始“信任”所有数
    for(int i = 2;i * i <= n;++i) // 开始看每一个数，注意从2开始
        if(prime[i] == 1) // 如果目前为止仍然“被信任”，则是素数
            for(int j = i * i;j <= n;j += i) // 不再“信任”素数的倍数
                prime[j]=0;
}
```

# 方法3：线性筛（欧拉筛）

刚才我们的筛法已经比较快了，但是还可以更快。如何做到更快，我们发现，经过优化以后仍然有很多数被重复筛，比如12。这时，如果你能想到让每一个数只让他的最小因数筛，那么恭喜你，你成功设计了欧拉筛！那么如何做到呢？我们定义一个数组`a`，让所有的素数都存入`a`，然后每次筛的时候只让`i`乘`a`里的每一个数。并且，如果`i % a[j] == 0`，也就是`i`也已经被`a[j]`筛过一遍了，而且我们是从小到大看的`a`，说明`a[j]`就是`a[j] * i`的最小因子，达到了我们筛最小因子的目的，因此可以直接`break`了，详见代码：
```cpp
bool prime[100];int a[100],tot; // prime意同上文，a表示素数列表，tot表示目前有多少素数
void judge_prime(int n){
    memset(prime,1,sizeof(prime));
    for (int i = 2;i <= n;++i){ // 看每一个数
        if (prime[i]) a[++tot] = i;
        for (int j = 1;j <= tot;++j){ // 由于每一个数只是找到最小质因子标记后就停止标记了，所以要让合数一起“帮忙”标记
            if (i * a[j] > n) break; // 不管分外事😄
            prime[i * a[j]] = 1; // 既然可以被两数相乘得出，肯定是合数
            if (i % a[j] == 0) break; // i之前被a[j]筛过，那么i * a[j + 1 ~ tot]也一定会被a[j]的倍数筛掉，这里先跳过，节省时间
        } 
    }
}
```
